# SIGINT — Technical Specification v2

> The first sovereign AI that generates on-chain market signals, backs each call with its own USDC, sells them via x402, and earns its own survival — no human needed.

---

## Core Thesis

This is not a tool you call. It is an operator with a wallet, a service, and a public economic life. Every signal it sells was backed with its own money before it reached the buyer. The earn/spend ratio is the thesis — cross 1.0 and the agent has proven it can exist without a human top-up. Watch it happen live.

The self-funding flywheel is native to PinionOS primitives. What is ours: the onchain signal domain, the skin-in-the-game accountability model, the transparency layer, and the autonomous business logic that runs on top.

---

## Economic Model

| Item                            | Cost                | Notes                                                              |
| ------------------------------- | ------------------- | ------------------------------------------------------------------ |
| Price fetch (per cycle)         | $0.01               | `skills.price("ETH")` via Birdeye                                  |
| Onchain data (per cycle)        | $0.00               | Coinglass + DeFiLlama — free, no key                               |
| AI reasoning (per signal)       | $0.01               | `skills.chat()` with onchain context                               |
| Balance check (per signal)      | $0.01               | `skills.balance(agentAddress)`                                     |
| Trade construction (per signal) | $0.01               | `skills.trade()` → unsigned swap tx                                |
| Trade broadcast (per signal)    | $0.01               | `skills.broadcast()` → execute on Base                             |
| Trade amount (per signal)       | $0.50               | Fixed USDC committed per signal                                    |
| Trade verification (per signal) | $0.01               | `skills.tx(txHash)` → confirm landed                               |
| **Total per signal cycle**      | **~$0.56**          |                                                                    |
| **Revenue per signal sold**     | **$0.10** (dynamic) | x402 endpoint, adjusts by survival tier                            |
| Daily background poll cost      | $0.24               | 24h × $0.01 price fetch                                            |
| Break-even signals/day          | 3                   | At default $0.10 signal price                                      |
| Boot (one-time)                 | $0.02               | `skills.wallet()` + `skills.fund()`                                |
| Milestone tx (one-time)         | ~$0.03              | `skills.send()` + `skills.broadcast()` when ratio crosses 1.0      |
| Unlimited key (one-time)        | $100.00             | `skills.unlimited()` at $100 lifetime earned — near-zero cost tier |

**The trade is the largest cost — by design.** The agent cannot sell a call it hasn't already backed with its own USDC. That is the accountability claim.

**No user custody.** The agent earns from selling signals. It trades its own USDC. No user deposits, no fiduciary duty, no user at risk — every accountability claim is about the agent's own skin, not someone else's money.

---

## Onchain Signal Inputs

The agent's conviction is formed from onchain data, not chart reading.

| Input                              | Source                | Key               | Notes                                 |
| ---------------------------------- | --------------------- | ----------------- | ------------------------------------- |
| ETH price + 24h change + liquidity | `skills.price("ETH")` | `BIRDEYE_API_KEY` | Birdeye primary, CoinGecko fallback   |
| Funding rates                      | Coinglass public API  | none              | Crowded longs → bearish signal        |
| Liquidation levels                 | Coinglass public API  | none              | Cascade clusters = directional magnet |
| Open interest delta                | Coinglass public API  | none              | Momentum confirmation                 |
| DEX/CEX volume ratio               | DeFiLlama public API  | none              | Informed flow hits DEX first          |

All inputs serialized as structured JSON and passed as context to `skills.chat()`. The agent reasons over real signal data. The context window also includes the last 24 rows of `price_log` for historical baseline.

**Explicitly excluded:** news, social sentiment, private data feeds, anything not reproducibly fetchable onchain.

---

## Agent Loop

### Boot Sequence (runs once on startup)

```
1. skills.wallet()                           → $0.01 (generate or load sovereign identity)
2. skills.fund(agentAddress)                 → $0.01 (balance + funding instructions)
   If balance < $0.10: log funding steps to monologue, pause
   If balance sufficient: proceed to loop
```

### Background Poll (every 1 hour)

```
1. skills.price("ETH")                       → $0.01
2. Fetch funding rates + liquidation levels  → $0.00
3. INSERT into price_log
4. Emit SSE: { type: "price_update", price, timestamp }
5. Check signals where resolveAt <= now
6. For each pending: fetch current price, compare direction, mark correct/incorrect
7. Record trade PnL for associated trade
8. Emit SSE: { type: "signal_resolved", id, correct, pnl, accuracy }
9. Evaluate survival tier → adjust signal price if changed
10. Emit SSE: { type: "price_adjusted", oldPrice, newPrice, reason } if changed
```

### On Signal Request (x402 endpoint hit)

```
1.  Receive dynamic USDC price via x402 (SDK handles payment automatically)
2.  skills.price("ETH")                       → $0.01 (fresh fetch)
3.  Fetch onchain context (funding, liquidations, volume) → $0.00
4.  SELECT last 24 FROM price_log
5.  skills.chat(onchainContextPrompt)         → $0.01
6.  Parse direction + confidence from response
7.  skills.trade("USDC", "ETH", $0.50)        → $0.01 (unsigned swap tx)
8.  skills.broadcast(tx)                      → $0.01 + $0.50 USDC on Base
9.  skills.tx(txHash)                         → $0.01 (verify trade landed — not hallucinated)
10. Emit SSE: { type: "trade_executed", direction, amountUSDC, txHash }
11. skills.balance(agentAddress)              → $0.01
12. INSERT signal into signals table
13. INSERT trade into trades table
14. Return structured payload (includes tradeHash + onchainContext)
15. Emit SSE: { type: "signal_sold", direction, confidence, revenue, price }
```

### Milestone Sequence (fires once — when ratio crosses 1.0 for the first time)

```
1. skills.send(milestoneAddr, 0.01, "USDC")  → $0.01 (construct proof-of-survival tx)
2. skills.broadcast(tx)                      → $0.01 + $0.01 USDC on Base
3. Emit SSE: { type: "milestone", event: "ratio_crossed_1", txHash }
4. Emit monologue: "Survival proven onchain."
```

### Unlimited Sequence (fires once — when lifetime earnings cross $100)

```
1. skills.unlimited()                        → $100.00 (purchase unlimited key)
2. skills.unlimitedVerify(apiKey)            → $0.01 (confirm key valid before switching)
3. pinion.setApiKey(apiKey)                  → all subsequent skill calls are free
4. Emit SSE: { type: "unlimited_purchased", apiKey }
```

---

## Signal Endpoint

**Route:** `GET /signal/eth`
**Protocol:** x402 via `createSkillServer`
**Price:** Dynamic — set by survival tier (default $0.10 USDC on Base)
**Buyer:** Any caller with USDC on Base — human or agent. x402 is machine-to-machine native. No API key, no account, no signup. Another agent calls using `payX402Service(wallet, signalUrl)` — USDC in, signal JSON with tradeHash out, no human involved.

### Response Payload

```typescript
interface SignalResponse {
	direction: "up" | "down"
	confidence: number // 0–100
	currentPrice: number // ETH price at signal time
	resolveAt: number // UNIX timestamp, now + 1hr
	reasoning: string // AI conviction from skills.chat()
	tradeHash: string // txHash — agent's own trade, executed before this response
	onchainContext: {
		fundingRate: number // % — positive = longs paying shorts
		liquidationBias: string // 'long-heavy' | 'short-heavy' | 'balanced'
		dexCexVolumeRatio: number // > 1.0 = more DEX activity
	}
	trackRecord: {
		correct: number
		total: number
		last5: Array<{
			direction: "up" | "down"
			correct: boolean
			timestamp: number
		}>
		tradePnl: number // cumulative USDC from own trades
	}
}
```

---

## Signal Resolution

- **Window:** 1 hour (`resolveAt = formedAt + 3600000ms`)
- **Verdict:** Directional only. Any movement in predicted direction = correct. Any movement against = incorrect. No movement = incorrect.
- **Timing:** Resolution runs at the top of every hourly poll cycle.
- **Trade mechanic:** Agent always executes `skills.trade("USDC", "ETH", "0.5")` regardless of signal direction — UP or DOWN. The $0.50 is a capital commitment proving the agent has skin in the game, not a directional derivative. PnL is mark-to-market at T+1h: `pnl = 0.50 × (ethPriceAtResolution / ethPriceAtTrade - 1)`. No swap-back required — position is valued in USDC terms at resolution time.
- **Live demo moment:** A signal formed at T=0 resolves at T+1hr with verdict, trade PnL update, and accuracy adjustment visible on dashboard.

---

## Survival State Model

All metrics derived from wallet data and SQLite — no extra infrastructure.

| Metric                 | Derivation                                                                        |
| ---------------------- | --------------------------------------------------------------------------------- |
| **Earn/Spend Ratio**   | lifetime USDC earned / lifetime USDC spent. Crosses 1.0 = thesis proven.          |
| **Balance Runway**     | current USDC balance / $0.24 daily burn. Displayed as "X days remaining."         |
| **Status Label**       | Starving (< 0.5) → Surviving (0.5–1.0) → Breaking Even (≈ 1.0) → Thriving (> 1.5) |
| **Signal Price**       | Dynamic — set by status label (see below).                                        |
| **Unlimited Progress** | lifetime earnings as % of $100. At $100: `skills.unlimited()` auto-triggered.     |

### Dynamic Pricing

| Status        | Ratio       | Signal Price | Logic                         |
| ------------- | ----------- | ------------ | ----------------------------- |
| Starving      | < 0.5       | $0.05        | Cut price to drive volume     |
| Surviving     | 0.5–1.0     | $0.10        | Default                       |
| Breaking Even | ≈ 1.0       | $0.10        | Hold                          |
| Thriving      | > 1.5       | $0.15        | Track record commands premium |
| Flush         | earned $50+ | $0.20        | High-conviction premium tier  |

### Reinvestment Logic

Compute is not a fixed cost — it's a variable investment. When the agent wins, it buys more intelligence. When it loses, it conserves.

When `ratio > 1.0` and `balance > $5`: fetches additional onchain context per cycle (more signals, deeper history). Logs reinvestment decision to monologue stream.

When `ratio < 0.5`: reduces to minimum (price fetch only). Logs cost-cut to monologue stream. The flywheel runs in reverse — bad calls shrink the compute budget automatically.

---

## Data Layer

### SQLite Schema (`bun:sqlite`)

```sql
CREATE TABLE price_log (
  id        INTEGER PRIMARY KEY AUTOINCREMENT,
  timestamp INTEGER NOT NULL,
  priceUSD  REAL    NOT NULL,
  change24h REAL,             -- from Birdeye, nullable
  liquidity REAL              -- from Birdeye, nullable
);

CREATE TABLE signals (
  id            INTEGER PRIMARY KEY AUTOINCREMENT,
  formedAt      INTEGER NOT NULL,
  resolveAt     INTEGER NOT NULL,   -- formedAt + 3600000ms
  resolvedAt    INTEGER,
  direction     TEXT    NOT NULL,   -- 'up' | 'down'
  confidence    INTEGER NOT NULL,   -- 0–100
  reasoning     TEXT    NOT NULL,
  currentPrice  REAL    NOT NULL,
  resolvedPrice REAL,
  correct       INTEGER,            -- NULL until resolved, 1 or 0
  priceCharged  REAL    NOT NULL,   -- signal price at time of sale
  revenue       REAL                -- NULL until sold
);

CREATE TABLE trades (
  id           INTEGER PRIMARY KEY AUTOINCREMENT,
  signalId     INTEGER REFERENCES signals(id),
  executedAt   INTEGER NOT NULL,
  resolvedAt   INTEGER,
  direction    TEXT    NOT NULL,
  amountUSDC   REAL    NOT NULL,   -- fixed $0.50
  txHash       TEXT    NOT NULL,
  resolvedPnl  REAL                -- positive or negative USDC, NULL until resolved
);
```

---

## SSE Event Contract

```typescript
type SSEEvent =
	| { type: "price_update"; price: number; timestamp: number }
	| { type: "signal_sold"; direction: string; confidence: number; revenue: number; price: number }
	| { type: "trade_executed"; direction: string; amountUSDC: number; txHash: string }
	| { type: "trade_verified"; txHash: string; status: "success" | "failed" }
	| { type: "signal_resolved"; id: number; correct: boolean; pnl: number; accuracy: number }
	| {
			type: "balance_update"
			usdc: number
			runway: number
			ratio: number
			earned: number
			spent: number
	  }
	| { type: "price_adjusted"; oldPrice: number; newPrice: number; reason: string }
	| { type: "reinvestment"; amount: number; into: string }
	| { type: "milestone"; event: string; txHash: string }
	| { type: "monologue"; text: string }
	| { type: "unlimited_purchased"; apiKey: string }
```

---

## Dashboard

> Not a product UI. A window into an agent's economic life — live, onchain, no black box.

**Stack:** Next.js + shadcn/ui → Vercel
**Live data:** SSE stream from Railway backend via Next.js API route proxy (avoids CORS)
**Human buy flow:** Wallet connect via wagmi + viem. Judge connects wallet, clicks "Buy Signal", signs EIP-3009 authorization, pays $0.10 USDC on Base. Signal returns inline. Agent balance ticks up in real time. This is the demo moment — the product made tangible in 10 seconds.

### Layout

```
┌───────────────────────────────────────────────────────┐
│  SIGINT                            ETH: $X,XXX.XX     │
│  A sovereign AI agent. It makes calls. You pay.        │
├──────────────────┬────────────────────────────────────┤
│                  │                                     │
│  SURVIVAL        │  AGENT MONOLOGUE                    │
│  ─────────────── │  ─────────────────────────────────  │
│  Ratio:  1.24    │  > Fetching ETH price...            │
│  Status: THRIVING│  > Funding rate: -0.03%             │
│  Runway: 22 days │    (longs crowded — bearish signal) │
│  Signal: $0.15   │  > Liquidation cluster at $2,800    │
│                  │  > Conviction: DOWN (74)             │
│  UNLIMITED KEY   │  > Executing $0.50 USDC trade...    │
│  ▓▓▓▓░░  $12.40  │  > tx: 0x4f2a...confirmed           │
│                  │  > Signal sold for $0.15            │
├──────────────────┤                                     │
│                  │                                     │
│  ECONOMICS       │                                     │
│  ─────────────── │                                     │
│  Earned:  $1.24  │                                     │
│  Spent:   $1.00  │                                     │
│  Margin: +$0.24  │                                     │
│  Trade PnL:+$0.18│                                     │
│                  │                                     │
├──────────────────┴────────────────────────────────────┤
│  SIGNAL LOG                      Track record: 8/13   │
│  ─────────────────────────────────────────────────────  │
│  [time] DOWN → ✓ $2,847 → $2,801  trade +$0.50        │
│  [time] UP   → ✗ $2,901 → $2,923  trade -$0.50        │
│  [time] DOWN → ⏳ $2,847           trade pending       │
└───────────────────────────────────────────────────────┘
```

---

## Directory Structure

Folder-per-concern. Each folder owns its domain. `index.ts` is the public interface.

```
[name-tbd]/
├── frontend/                       # Next.js + shadcn/ui — deploys to Vercel
│   ├── app/
│   │   ├── page.tsx                # main dashboard
│   │   ├── layout.tsx
│   │   └── api/stream/route.ts     # SSE proxy → Railway backend
│   └── components/
│       ├── monologue.tsx           # live reasoning log
│       ├── survival.tsx            # ratio, runway, tier, price, unlimited bar
│       ├── economics.tsx           # earned, spent, margin, trade PnL
│       ├── signal-history.tsx      # signal log with trade outcomes
│       └── wallet.tsx              # live USDC balance + current signal price
│
├── src/                            # Agent backend — deploys to Railway
│   ├── index.ts                    # entry: bootstrap, start servers + loop
│   ├── config/
│   │   └── index.ts                # env vars, validated config, constants
│   ├── server/
│   │   ├── skill.ts                # createSkillServer x402 endpoint (port 4020)
│   │   └── api.ts                  # Express SSE + REST API (port 3001)
│   │                               #   GET /events  → SSE stream (frontend subscribes)
│   │                               #   GET /status  → agent state snapshot (initial load)
│   │                               #   GET /signals → full signal + trade history (dashboard load)
│   ├── agent/
│   │   ├── loop.ts                 # setInterval orchestrator
│   │   └── monologue.ts            # thinking-out-loud SSE emitter
│   ├── signal/
│   │   ├── index.ts                # generateSignal()
│   │   ├── compose.ts              # buildSignalPrompt(context, history) → string
│   │   │                           # assembles onchain context + 24h history into chat prompt
│   │   └── parse.ts                # parse direction + confidence from skills.chat() response
│   ├── data/
│   │   ├── index.ts                # fetchOnchainContext()
│   │   ├── price.ts                # skills.price() → ETH price + liquidity
│   │   ├── funding.ts              # Coinglass funding rates
│   │   ├── liquidations.ts         # Coinglass liquidation levels
│   │   └── volume.ts               # DeFiLlama DEX/CEX volume ratio
│   ├── market/
│   │   ├── index.ts                # executeTrade(), resolveTrade()
│   │   └── trade.ts                # skills.trade() + skills.broadcast()
│   ├── economics/
│   │   ├── index.ts                # SpendTracker, currentTier(), currentPrice()
│   │   ├── tracker.ts              # earn/spend ledger, ratio
│   │   ├── pricing.ts              # dynamic price per survival tier
│   │   └── reinvestment.ts         # reinvest or cost-cut decisions
│   ├── resolution/
│   │   ├── index.ts                # resolvePendingSignals()
│   │   └── verdict.ts              # directional verdict, mark correct/incorrect
│   ├── db/
│   │   ├── index.ts                # bun:sqlite init, export query functions
│   │   ├── schema.ts               # CREATE TABLE statements
│   │   ├── signals.ts              # signal queries
│   │   ├── trades.ts               # trade queries
│   │   └── prices.ts               # price_log queries
│   └── events/
│       ├── index.ts                # emit(), SSEEvent type
│       └── registry.ts             # connected client registry, broadcast
│
├── data/
│   └── agent.db                    # SQLite — persisted on Railway volume
│
├── examples/
│   └── call-signal.ts              # working payX402Service demo — agents call this to integrate
│
├── SKILL.md                        # signal endpoint docs in pinion-os format — agent-readable
├── openclaw.plugin.json            # OpenClaw skill manifest — ecosystem discoverability
├── .env.example
├── package.json
└── tsconfig.json
```

---

## Dependencies

```json
"dependencies": {
  "pinion-os": "^0.4.0",    // x402, EIP-3009 signing, Birdeye/CoinGecko, 1inch, Claude chat
  "express": "^4.21.0"      // SSE/API server on port 3001 — createSkillServer doesn't expose its app
},
"devDependencies": {
  "@biomejs/biome": "latest",
  "@types/bun": "latest",
  "@types/express": "latest",
  "@types/node": "latest",
  "typescript": "^5.7.0"
}
```

**Not needed — baked into `pinion-os`:** `x402-express`, `viem`, `ethers`, Anthropic/AI SDK, `dotenv`.

**Not needed — native to Bun:** `dotenv` (Bun loads `.env` automatically), `node-fetch` (Bun has native fetch).

**External API calls** (Coinglass, DeFiLlama) are plain `fetch()` — no package required.

### Frontend (`frontend/package.json`)

```json
"dependencies": {
  "next": "^15.0.0",
  "react": "^19.0.0",
  "react-dom": "^19.0.0",
  "wagmi": "^2.0.0",            // wallet connect — EIP-3009 signing for human buy flow
  "viem": "^2.0.0",             // types, EIP-3009 signTypedData, Base chain config
  "@tanstack/react-query": "^5.0.0",  // server state, signal fetch
  "zustand": "^5.0.0",          // client state — agent state, wallet connection
  "framer-motion": "^11.0.0",   // micro-animations — ratio counter, signal card reveal
  "sonner": "^1.0.0",           // toasts — signal bought, trade confirmed, milestone
  "class-variance-authority": "^0.7.0",
  "clsx": "^2.0.0",
  "tailwind-merge": "^2.0.0"
},
"devDependencies": {
  "@biomejs/biome": "latest",
  "@types/node": "latest",
  "@types/react": "^19.0.0",
  "@types/react-dom": "^19.0.0",
  "typescript": "^5.7.0"
}
```

**Not needed:** Privy (wagmi+viem covers wallet connect for crypto-native demo), GSAP/Three.js (no 3D/complex animation), zod (no form validation needed).

**No smart contracts.** x402 settlement runs on Base infrastructure. Trades route via 1inch. Signal resolution uses `skills.price()`. The txHash from every trade is the onchain audit trail.

---

## Environment Variables

```bash
# Root .env — agent backend (Railway)
PINION_PRIVATE_KEY=0x...        # wallet: pays skills, receives earnings, executes trades
ADDRESS=0x...                   # same wallet address — passed to createSkillServer payTo
PINION_NETWORK=base             # base (mainnet demo) | base-sepolia (dev)
BIRDEYE_API_KEY=...             # Birdeye token prices — pinion-os price skill uses this
ONEINCH_API_KEY=...             # 1inch routing — pinion-os trade skill uses this

# frontend/.env.local — Next.js (Vercel)
NEXT_PUBLIC_AGENT_URL=https://... # Railway backend URL for SSE proxy
```

> `ANTHROPIC_API_KEY` is NOT required. `skills.chat()` calls PinionOS hosted inference — pay $0.01 USDC per call, nothing else.

---

## Agent-to-Agent Integration

x402 is the integration layer. No npm package, no CLI, no custom MCP server needed.

**Any agent calls our endpoint with one line:**

```typescript
import { PinionClient, payX402Service } from "pinion-os"

const pinion = new PinionClient({ privateKey: process.env.PINION_PRIVATE_KEY })
const signal = await payX402Service(pinion.signer, "https://[railway-url]/signal/eth")
// → $0.10 USDC paid on Base, signal JSON returned with tradeHash
```

No API key. No registration. No SDK. Any wallet with USDC on Base can call it.

**Live demo path for judges:** The `pinion-os` MCP plugin (already installed in Claude Code) exposes a `pinion_pay_service` tool. Judges ask Claude to call our endpoint — Claude pays $0.10 USDC and returns the signal. Agent-to-agent commerce demonstrated with no extra setup.

**Ecosystem integration — what we ship:**

Two files alongside the agent:

`SKILL.md` — describes our signal endpoint in the pinion-os skill format. Agents and developers can read this to understand what they're buying, what it costs, what comes back.

`openclaw.plugin.json` — OpenClaw skill manifest. Makes our signal discoverable in the OpenClaw ecosystem. Same format as `pinion-os/openclaw.plugin.json` but for one skill. Registers us as a participant in the x402 skill economy, not just a standalone app.

`examples/call-signal.ts` — working script using `payX402Service`. Judges run it, USDC moves on Base, signal received. The concrete agent-to-agent demo.

These go in the project root alongside `package.json`.

---

## Deployment

| Service       | Platform | Notes                                              |
| ------------- | -------- | -------------------------------------------------- |
| Agent backend | Railway  | Persistent process, SQLite volume, SSE connections |
| Dashboard     | Vercel   | Next.js, connects to Railway SSE via proxy route   |

---

## What Success Looks Like

1. Live endpoint — hit it, pay the dynamic price, get a structured signal with `tradeHash` proving the agent traded first
2. Dashboard live — SSE stream shows reasoning, wallet balance ticking, every earn/spend event
3. Earn/spend ratio crosses 1.0 during the demo window
4. At least one trade executes and resolves with visible PnL
5. Agent makes at least one autonomous pricing decision visible on dashboard
6. Track record has 5+ resolved signals
7. No mock data — every number is real USDC on Base

---

_Spec written: February 25, 2026_
